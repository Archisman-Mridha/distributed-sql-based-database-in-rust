use std::fmt::Display;

pub enum Token {
  // A numeric string, with digits, decimal points, and/or exponents.
  // Leading signs (e.g. -) are separate tokens.
  Number(String),

  // A Unicode string, with quotes stripped and escape sequences resolved.
  String(String),

  Question,

  // An identifier, with any quotes stripped.
  Identifier(String),

  Keyword(Keyword),

  Period,

  Equal,
  NotEqual,
  GreaterThan,
  GreaterThanOrEqual,
  LessThan,
  LessThanOrEqual,
  LessOrGreaterThan,
  Exclamation,

  Plus,
  Minus,
  Asterisk,
  Slash,
  Caret,
  Percent,

  OpenParenthesis,
  CloseParenthesis,

  Comma,
  Semicolon,
}

impl Display for Token {
  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
    f.write_str(match self {
      Self::Number(n) => n,
      Self::String(s) => s,
      Self::Identifier(s) => s,
      Self::Keyword(k) => return k.fmt(f),
      Self::Period => ".",
      Self::Equal => "=",
      Self::NotEqual => "!=",
      Self::GreaterThan => ">",
      Self::GreaterThanOrEqual => ">=",
      Self::LessThan => "<",
      Self::LessThanOrEqual => "<=",
      Self::LessOrGreaterThan => "<>",
      Self::Plus => "+",
      Self::Minus => "-",
      Self::Asterisk => "*",
      Self::Slash => "/",
      Self::Caret => "^",
      Self::Percent => "%",
      Self::Exclamation => "!",
      Self::Question => "?",
      Self::Comma => ",",
      Self::Semicolon => ";",
      Self::OpenParenthesis => "(",
      Self::CloseParenthesis => ")",
    })
  }
}

impl From<Keyword> for Token {
  fn from(keyword: Keyword) -> Self {
    Token::Keyword(keyword)
  }
}

pub enum Keyword {
  AND,
  AS,
  ASC,
  BEGIN,
  BOOL,
  BOOLEAN,
  BY,
  COMMIT,
  CREATE,
  CROSS,
  DEFAULT,
  DELETE,
  DESC,
  DOUBLE,
  DROP,
  EXISTS,
  EXPLAIN,
  FALSE,
  FLOAT,
  FROM,
  GROUP,
  HAVING,
  IF,
  INDEX,
  INFINITY,
  INNER,
  INSERT,
  INT,
  INTEGER,
  INTO,
  IS,
  JOIN,
  KEY,
  LEFT,
  LIKE,
  LIMIT,
  NAN,
  NOT,
  NULL,
  OF,
  OFFSET,
  ON,
  ONLY,
  OR,
  ORDER,
  OUTER,
  PRIMARY,
  READ,
  REFERENCES,
  RIGHT,
  ROLLBACK,
  SELECT,
  SET,
  STRING,
  SYSTEM,
  TABLE,
  TEXT,
  TIME,
  TRANSACTION,
  TRUE,
  UNIQUE,
  UPDATE,
  VALUES,
  VARCHAR,
  WHERE,
  WRITE,
}

impl TryFrom<&str> for Keyword {
  type Error = &'static str;

  fn try_from(value: &str) -> std::result::Result<Self, Self::Error> {
    debug_assert!(
      value.chars().all(|c| !c.is_uppercase()),
      "Keyword must be lowercase"
    );

    Ok(match value {
      "as" => Self::AS,
      "asc" => Self::ASC,
      "and" => Self::AND,
      "begin" => Self::BEGIN,
      "bool" => Self::BOOL,
      "boolean" => Self::BOOLEAN,
      "by" => Self::BY,
      "commit" => Self::COMMIT,
      "create" => Self::CREATE,
      "cross" => Self::CROSS,
      "default" => Self::DEFAULT,
      "delete" => Self::DELETE,
      "desc" => Self::DESC,
      "double" => Self::DOUBLE,
      "drop" => Self::DROP,
      "exists" => Self::EXISTS,
      "explain" => Self::EXPLAIN,
      "false" => Self::FALSE,
      "float" => Self::FLOAT,
      "from" => Self::FROM,
      "group" => Self::GROUP,
      "having" => Self::HAVING,
      "if" => Self::IF,
      "index" => Self::INDEX,
      "infinity" => Self::INFINITY,
      "inner" => Self::INNER,
      "insert" => Self::INSERT,
      "int" => Self::INT,
      "integer" => Self::INTEGER,
      "into" => Self::INTO,
      "is" => Self::IS,
      "join" => Self::JOIN,
      "key" => Self::KEY,
      "left" => Self::LEFT,
      "like" => Self::LIKE,
      "limit" => Self::LIMIT,
      "nan" => Self::NAN,
      "not" => Self::NOT,
      "null" => Self::NULL,
      "of" => Self::OF,
      "offset" => Self::OFFSET,
      "on" => Self::ON,
      "only" => Self::ONLY,
      "or" => Self::OR,
      "order" => Self::ORDER,
      "outer" => Self::OUTER,
      "primary" => Self::PRIMARY,
      "read" => Self::READ,
      "references" => Self::REFERENCES,
      "right" => Self::RIGHT,
      "rollback" => Self::ROLLBACK,
      "select" => Self::SELECT,
      "set" => Self::SET,
      "string" => Self::STRING,
      "system" => Self::SYSTEM,
      "table" => Self::TABLE,
      "text" => Self::TEXT,
      "time" => Self::TIME,
      "transaction" => Self::TRANSACTION,
      "true" => Self::TRUE,
      "unique" => Self::UNIQUE,
      "update" => Self::UPDATE,
      "values" => Self::VALUES,
      "varchar" => Self::VARCHAR,
      "where" => Self::WHERE,
      "write" => Self::WRITE,
      _ => return Err("not a keyword"),
    })
  }
}

impl Display for Keyword {
  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
    f.write_str(match self {
      Self::AS => "AS",
      Self::ASC => "ASC",
      Self::AND => "AND",
      Self::BEGIN => "BEGIN",
      Self::BOOL => "BOOL",
      Self::BOOLEAN => "BOOLEAN",
      Self::BY => "BY",
      Self::COMMIT => "COMMIT",
      Self::CREATE => "CREATE",
      Self::CROSS => "CROSS",
      Self::DEFAULT => "DEFAULT",
      Self::DELETE => "DELETE",
      Self::DESC => "DESC",
      Self::DOUBLE => "DOUBLE",
      Self::DROP => "DROP",
      Self::EXISTS => "EXISTS",
      Self::EXPLAIN => "EXPLAIN",
      Self::FALSE => "FALSE",
      Self::FLOAT => "FLOAT",
      Self::FROM => "FROM",
      Self::GROUP => "GROUP",
      Self::HAVING => "HAVING",
      Self::IF => "IF",
      Self::INDEX => "INDEX",
      Self::INFINITY => "INFINITY",
      Self::INNER => "INNER",
      Self::INSERT => "INSERT",
      Self::INT => "INT",
      Self::INTEGER => "INTEGER",
      Self::INTO => "INTO",
      Self::IS => "IS",
      Self::JOIN => "JOIN",
      Self::KEY => "KEY",
      Self::LEFT => "LEFT",
      Self::LIKE => "LIKE",
      Self::LIMIT => "LIMIT",
      Self::NAN => "NAN",
      Self::NOT => "NOT",
      Self::NULL => "NULL",
      Self::OF => "OF",
      Self::OFFSET => "OFFSET",
      Self::ON => "ON",
      Self::ONLY => "ONLY",
      Self::OUTER => "OUTER",
      Self::OR => "OR",
      Self::ORDER => "ORDER",
      Self::PRIMARY => "PRIMARY",
      Self::READ => "READ",
      Self::REFERENCES => "REFERENCES",
      Self::RIGHT => "RIGHT",
      Self::ROLLBACK => "ROLLBACK",
      Self::SELECT => "SELECT",
      Self::SET => "SET",
      Self::STRING => "STRING",
      Self::SYSTEM => "SYSTEM",
      Self::TABLE => "TABLE",
      Self::TEXT => "TEXT",
      Self::TIME => "TIME",
      Self::TRANSACTION => "TRANSACTION",
      Self::TRUE => "TRUE",
      Self::UNIQUE => "UNIQUE",
      Self::UPDATE => "UPDATE",
      Self::VALUES => "VALUES",
      Self::VARCHAR => "VARCHAR",
      Self::WHERE => "WHERE",
      Self::WRITE => "WRITE",
    })
  }
}
